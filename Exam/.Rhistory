samp_vec = c(sample(x=I, size=m ,replace=TRUE))
df[paste("n",n , sep="")] = samp_vec
mean_uniq_vec = c(mean_uniq_vec, mean(unique(samp_vec)))
sd_uniq_vec = c(sd_uniq_vec, sd(unique(samp_vec)))
}
#visualize data
par(mfrow=c(3,2))
for(i in names(df)[2:7]){
hist(df[[i]],
xlab = "number",
main=i)
}
# make table of results
# table$Mean_All = myRound(apply(df[,2:7], 2, mean), acc=2)
# table$SD_All = myRound(apply(df[,2:7], 2, sd), acc=2)
table_df$Mean_Unique = mean_uniq_vec
table_df$SD_Unique = sd_uniq_vec
table_df = data.frame(t(table_df))
knitr::kable(table, format = "markdown")
View(table_df)
myRound <- function(x, acc=3) {mult = 10^acc; round(x*mult)/mult}
set.seed(0)
n = 100
m=1000
origData = rnorm(n) # case 1
z=sample(x=origData, size=n*m, replace=TRUE)
case1_mat <- matrix(z,nrow=m)
origData = rt(n,df=3); # case 2
z=sample(x=origData, size=n*m, replace=TRUE)
case2_mat <- matrix(z,nrow=m)
origData = rt(n,df=25); # case 3
z=sample(x=origData, size=n*m, replace=TRUE)
case3_mat <- matrix(z,nrow=m)
myCVids <- function(n, K, seed=0) {
# balanced subsets generation (subset sizes differ by at most 1)
# n is the number of observations/rows in the training set
# K is the desired number of folds (e.g., 5 or 10)
set.seed(seed);
t = floor(n/K); r = n-t*K;
id0 = rep((1:K),times=t)
ids = sample(id0,t*K)
if (r > 0) {ids = c(ids, sample(K,r))}
ids
}
# Generate data
set.seed(0)
nr = 50
nc = 200*2^5 # nc = 6400
M = matrix(rnorm(nr*nc),nrow=50)
Y = c(rep(1,25),rep(0,25))
genData <- function(n, seed=0) {
set.seed(seed)
x = seq(-1,1,length.out=n)
y = x - x^2 + 2*rnorm(n) # true sigma = 2;
out.df = data.frame(x=x, y=y)
out.df
}
train.df = genData(n=200,seed=100)
test.df = genData(400)
# assume values for x and cfp
# x = 0.25
cfp=1
n=100
x_vec=c()
A_vec=c()
C_vec=c()
R_vec=c()
FPR_vec=c()
TPR_vec=c()
G_vec=c()
for (x in seq(0.01,0.99,0.01)) {
A=c(0.5, 0.2)
C=c(cfp, 10*cfp)
R=c(x, sqrt(x))
Ai=0
for(q in A){
Ai = Ai+1
P=n*q
N=n*(1-q)
Ri=0
for(tpr in R){
Ri=Ri+1
# calculate TP, FP, TN, and FN with regards to x
TP = tpr*P
FN = P-TP
FP = x*N
TN = N-FP
FPR = x
TPR = tpr
Ci=0
for(cfn in C){
Ci=Ci+1
G = cfn*FN + cfp*FP
x_vec=c(x_vec,x)
A_vec=c(A_vec,Ai)
C_vec=c(C_vec,Ci)
R_vec=c(R_vec,Ri)
FPR_vec=c(FPR_vec,FPR)
TPR_vec=c(TPR_vec,TPR)
G_vec=c(G_vec,G)
# print(paste("(A:",as.character(Ai),")"))
# print(paste("(C:",as.character(Ci),")"))
# print(paste("(R:",as.character(Ri),")"))
# print(paste("FPR = ", FPR))
# print(paste("TPR = ", TPR))
# print(paste("G = ", G))
# print("----------------------------")
}
}
}
}
results_df = data.frame(x_vec,
A_vec,
C_vec,
R_vec,
FPR_vec,
TPR_vec,
G_vec)
results_df$design_id <- paste(results_df$A_vec,
results_df$C_vec,
results_df$R_vec)
# Objective function score visualization
plot(x=results_df$x_vec,
y=results_df$G_vec,
col=factor(results_df$design_id),
ylab="G (misclassification cost)",
xlab="x (FPR)")
# Generate data
set.seed(0)
n_vec = c(25, 50, 100, 200, 400, 800)
m = 1000
df = data.frame(m=1:m)
table_df = data.frame(n=n_vec) # results table
mean_uniq_vec = c()
sd_uniq_vec = c()
for (n in n_vec){
I = seq(n)
samp_vec = c(sample(x=I, size=m ,replace=TRUE))
df[paste("n",n , sep="")] = samp_vec
mean_uniq_vec = c(mean_uniq_vec, mean(unique(samp_vec)))
sd_uniq_vec = c(sd_uniq_vec, sd(unique(samp_vec)))
}
#visualize data
par(mfrow=c(3,2))
for(i in names(df)[2:7]){
hist(df[[i]],
xlab = "number",
main=i)
}
# make table of results
table_df$Mean_Unique = mean_uniq_vec
table_df$SD_Unique = sd_uniq_vec
table_df = data.frame(t(table_df))
knitr::kable(table_df, format = "markdown")
origData = seq(n)
z=sample(x=origData, size=n*m, replace=TRUE)
samp_mat <- matrix(z,nrow=m)
View(samp_mat)
I1 = seq(n_vec[1])
I2 = seq(n_vec[2])
sample(x=c(I1,I2), size=m ,replace=TRUE)
a = sample(x=c(I1,I2), size=m ,replace=TRUE)
z = sample(x=c(I1,I2), size=m ,replace=TRUE)
samp_mat <- matrix(z,nrow=m)
View(samp_mat)
I1 = seq(n_vec[1])
I2 = seq(n_vec[2])
z = sample(x=c(I1,I2), size=n*m ,replace=TRUE)
samp_mat <- matrix(z,nrow=m)
View(samp_mat)
z = sample(x=c(I1,I2), size=length(n_vec)*m ,replace=TRUE)
samp_mat <- matrix(z,nrow=m)
View(samp_mat)
I2 = seq(n_vec[2])
I3 = seq(n_vec[3])
I4 = seq(n_vec[4])
I5 = seq(n_vec[5])
I6 = seq(n_vec[6])
z = sample(x=c(I1,I2,I3,I4,I5,I6), size=length(n_vec)*m ,replace=TRUE)
samp_mat <- matrix(z,nrow=m)
z = sample(x=n_vec, size=length(n_vec)*m ,replace=TRUE)
samp_mat <- matrix(z,nrow=m)
View(samp_mat)
# Generate data
set.seed(0)
n_vec = c(25, 50, 100, 200, 400, 800)
m = 1000
df = data.frame(m=1:m)
table_df = data.frame(n=n_vec) # results table
mean_uniq_vec = c()
sd_uniq_vec = c()
for (n in n_vec){
I = seq(n)
samp_vec = c(sample(x=I, size=m ,replace=TRUE))
df[paste("n",n , sep="")] = samp_vec
mean_uniq_vec = c(mean_uniq_vec, mean(unique(samp_vec)))
sd_uniq_vec = c(sd_uniq_vec, sd(unique(samp_vec)))
}
#visualize data
par(mfrow=c(3,2))
for(i in names(df)[2:7]){
hist(df[[i]],
xlab = "number",
main=i)
}
# make table of results
table_df$Mean_Unique = mean_uniq_vec
table_df$SD_Unique = sd_uniq_vec
table_df = data.frame(t(table_df))
knitr::kable(table_df, format = "markdown")
# make table of results
table_df$Mean_Unique = myRound(mean_uniq_vec, acc=2)
mean_uniq_vec
# make table of results
table_df$Mean_Unique = myRound(mean_uniq_vec, acc=2)
# Generate data
set.seed(0)
n_vec = c(25, 50, 100, 200, 400, 800)
m = 1000
df = data.frame(m=1:m)
table_df = data.frame(n=n_vec) # results table
mean_uniq_vec = c()
sd_uniq_vec = c()
for (n in n_vec){
I = seq(n)
samp_vec = c(sample(x=I, size=m ,replace=TRUE))
df[paste("n",n , sep="")] = samp_vec
mean_uniq_vec = c(mean_uniq_vec, mean(unique(samp_vec)))
sd_uniq_vec = c(sd_uniq_vec, sd(unique(samp_vec)))
}
#visualize data
par(mfrow=c(3,2))
for(i in names(df)[2:7]){
hist(df[[i]],
xlab = "number",
main=i)
}
# make table of results
table_df$Mean_Unique = myRound(mean_uniq_vec, acc=2)
table_df$SD_Unique = myRound(sd_uniq_vec, acc=2)
table_df = data.frame(t(table_df))
knitr::kable(table_df, format = "markdown")
myRound <- function(x, acc=3) {mult = 10^acc; round(x*mult)/mult}
set.seed(0)
n = 100
m=1000
origData = rnorm(n) # case 1
z=sample(x=origData, size=n*m, replace=TRUE)
case1_mat <- matrix(z,nrow=m)
origData = rt(n,df=3); # case 2
z=sample(x=origData, size=n*m, replace=TRUE)
case2_mat <- matrix(z,nrow=m)
origData = rt(n,df=25); # case 3
z=sample(x=origData, size=n*m, replace=TRUE)
case3_mat <- matrix(z,nrow=m)
myCVids <- function(n, K, seed=0) {
# balanced subsets generation (subset sizes differ by at most 1)
# n is the number of observations/rows in the training set
# K is the desired number of folds (e.g., 5 or 10)
set.seed(seed);
t = floor(n/K); r = n-t*K;
id0 = rep((1:K),times=t)
ids = sample(id0,t*K)
if (r > 0) {ids = c(ids, sample(K,r))}
ids
}
# Generate data
set.seed(0)
nr = 50
nc = 200*2^5 # nc = 6400
M = matrix(rnorm(nr*nc),nrow=50)
Y = c(rep(1,25),rep(0,25))
genData <- function(n, seed=0) {
set.seed(seed)
x = seq(-1,1,length.out=n)
y = x - x^2 + 2*rnorm(n) # true sigma = 2;
out.df = data.frame(x=x, y=y)
out.df
}
train.df = genData(n=200,seed=100)
test.df = genData(400)
# assume values for x and cfp
# x = 0.25
cfp=1
n=100
x_vec=c()
A_vec=c()
C_vec=c()
R_vec=c()
FPR_vec=c()
TPR_vec=c()
G_vec=c()
for (x in seq(0.01,0.99,0.01)) {
A=c(0.5, 0.2)
C=c(cfp, 10*cfp)
R=c(x, sqrt(x))
Ai=0
for(q in A){
Ai = Ai+1
P=n*q
N=n*(1-q)
Ri=0
for(tpr in R){
Ri=Ri+1
# calculate TP, FP, TN, and FN with regards to x
TP = tpr*P
FN = P-TP
FP = x*N
TN = N-FP
FPR = x
TPR = tpr
Ci=0
for(cfn in C){
Ci=Ci+1
G = cfn*FN + cfp*FP
x_vec=c(x_vec,x)
A_vec=c(A_vec,Ai)
C_vec=c(C_vec,Ci)
R_vec=c(R_vec,Ri)
FPR_vec=c(FPR_vec,FPR)
TPR_vec=c(TPR_vec,TPR)
G_vec=c(G_vec,G)
# print(paste("(A:",as.character(Ai),")"))
# print(paste("(C:",as.character(Ci),")"))
# print(paste("(R:",as.character(Ri),")"))
# print(paste("FPR = ", FPR))
# print(paste("TPR = ", TPR))
# print(paste("G = ", G))
# print("----------------------------")
}
}
}
}
results_df = data.frame(x_vec,
A_vec,
C_vec,
R_vec,
FPR_vec,
TPR_vec,
G_vec)
results_df$design_id <- paste(results_df$A_vec,
results_df$C_vec,
results_df$R_vec)
# Objective function score visualization
plot(x=results_df$x_vec,
y=results_df$G_vec,
col=factor(results_df$design_id),
ylab="G (misclassification cost)",
xlab="x (FPR)")
# Generate data
set.seed(0)
n_vec = c(25, 50, 100, 200, 400, 800)
m = 1000
df = data.frame(m=1:m)
table_df = data.frame(n=n_vec) # results table
mean_uniq_vec = c()
sd_uniq_vec = c()
for (n in n_vec){
I = seq(n)
samp_vec = c(sample(x=I, size=m ,replace=TRUE))
df[paste("n",n , sep="")] = samp_vec
mean_uniq_vec = c(mean_uniq_vec, mean(unique(samp_vec)))
sd_uniq_vec = c(sd_uniq_vec, sd(unique(samp_vec)))
}
#visualize data
par(mfrow=c(3,2))
for(i in names(df)[2:7]){
hist(df[[i]],
xlab = "number",
main=i)
}
# make table of results
table_df$Mean_Unique = myRound(mean_uniq_vec, acc=2)
table_df$SD_Unique = myRound(sd_uniq_vec, acc=2)
table_df = data.frame(t(table_df))
knitr::kable(table_df, format = "markdown")
# make table of results
table_df$Mean_Unique = myRound(mean_uniq_vec, acc=2)
myRound <- function(x, acc=3) {mult = 10^acc; round(x*mult)/mult}
set.seed(0)
n = 100
m=1000
origData = rnorm(n) # case 1
z=sample(x=origData, size=n*m, replace=TRUE)
case1_mat <- matrix(z,nrow=m)
origData = rt(n,df=3); # case 2
z=sample(x=origData, size=n*m, replace=TRUE)
case2_mat <- matrix(z,nrow=m)
origData = rt(n,df=25); # case 3
z=sample(x=origData, size=n*m, replace=TRUE)
case3_mat <- matrix(z,nrow=m)
myCVids <- function(n, K, seed=0) {
# balanced subsets generation (subset sizes differ by at most 1)
# n is the number of observations/rows in the training set
# K is the desired number of folds (e.g., 5 or 10)
set.seed(seed);
t = floor(n/K); r = n-t*K;
id0 = rep((1:K),times=t)
ids = sample(id0,t*K)
if (r > 0) {ids = c(ids, sample(K,r))}
ids
}
# Generate data
set.seed(0)
nr = 50
nc = 200*2^5 # nc = 6400
M = matrix(rnorm(nr*nc),nrow=50)
Y = c(rep(1,25),rep(0,25))
genData <- function(n, seed=0) {
set.seed(seed)
x = seq(-1,1,length.out=n)
y = x - x^2 + 2*rnorm(n) # true sigma = 2;
out.df = data.frame(x=x, y=y)
out.df
}
train.df = genData(n=200,seed=100)
test.df = genData(400)
# assume values for x and cfp
# x = 0.25
cfp=1
n=100
x_vec=c()
A_vec=c()
C_vec=c()
R_vec=c()
FPR_vec=c()
TPR_vec=c()
G_vec=c()
for (x in seq(0.01,0.99,0.01)) {
A=c(0.5, 0.2)
C=c(cfp, 10*cfp)
R=c(x, sqrt(x))
Ai=0
for(q in A){
Ai = Ai+1
P=n*q
N=n*(1-q)
Ri=0
for(tpr in R){
Ri=Ri+1
# calculate TP, FP, TN, and FN with regards to x
TP = tpr*P
FN = P-TP
FP = x*N
TN = N-FP
FPR = x
TPR = tpr
Ci=0
for(cfn in C){
Ci=Ci+1
G = cfn*FN + cfp*FP
x_vec=c(x_vec,x)
A_vec=c(A_vec,Ai)
C_vec=c(C_vec,Ci)
R_vec=c(R_vec,Ri)
FPR_vec=c(FPR_vec,FPR)
TPR_vec=c(TPR_vec,TPR)
G_vec=c(G_vec,G)
# print(paste("(A:",as.character(Ai),")"))
# print(paste("(C:",as.character(Ci),")"))
# print(paste("(R:",as.character(Ri),")"))
# print(paste("FPR = ", FPR))
# print(paste("TPR = ", TPR))
# print(paste("G = ", G))
# print("----------------------------")
}
}
}
}
results_df = data.frame(x_vec,
A_vec,
C_vec,
R_vec,
FPR_vec,
TPR_vec,
G_vec)
results_df$design_id <- paste(results_df$A_vec,
results_df$C_vec,
results_df$R_vec)
# Objective function score visualization
plot(x=results_df$x_vec,
y=results_df$G_vec,
col=factor(results_df$design_id),
ylab="G (misclassification cost)",
xlab="x (FPR)")
# Generate data
set.seed(0)
n_vec = c(25, 50, 100, 200, 400, 800)
m = 1000
df = data.frame(m=1:m)
table_df = data.frame(n=n_vec) # results table
mean_uniq_vec = c()
sd_uniq_vec = c()
for (n in n_vec){
I = seq(n)
samp_vec = c(sample(x=I, size=m ,replace=TRUE))
df[paste("n",n , sep="")] = samp_vec
mean_uniq_vec = c(mean_uniq_vec, mean(unique(samp_vec)))
sd_uniq_vec = c(sd_uniq_vec, sd(unique(samp_vec)))
}
#visualize data
par(mfrow=c(3,2))
for(i in names(df)[2:7]){
hist(df[[i]],
xlab = "number",
main=i)
}
# make table of results
table_df$Mean_Unique = myRound(mean_uniq_vec, acc=2)
table_df$SD_Unique = myRound(sd_uniq_vec, acc=2)
table_df = data.frame(t(table_df))
knitr::kable(table_df, format = "markdown")
